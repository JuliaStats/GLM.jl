<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GLM Documentation · GLM</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GLM</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">GLM Documentation</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Fitting-GLM-models-1">Fitting GLM models</a></li><li><a class="toctext" href="#Methods-applied-to-fitted-models-1">Methods applied to fitted models</a></li><li><a class="toctext" href="#Minimal-examples-1">Minimal examples</a></li><li><a class="toctext" href="#Other-examples-1">Other examples</a></li><li><a class="toctext" href="#Separation-of-response-object-and-predictor-object-1">Separation of response object and predictor object</a></li><li><a class="toctext" href="#API-1">API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">GLM Documentation</a></li></ul><a class="edit-page" href="https://github.com/JuliaStats/GLM.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>GLM Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="GLM-Documentation-1" href="#GLM-Documentation-1">GLM Documentation</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><pre><code class="language-julia">Pkg.add(&quot;GLM&quot;)</code></pre><p>will install this package and its dependencies, which includes the <a href="https://github.com/JuliaStats/Distributions.jl">Distributions package</a>.</p><p>The <a href="https://github.com/johnmyleswhite/RDatasets.jl">RDatasets package</a> is useful for fitting models on standard R datasets to compare the results with those from R.</p><h2><a class="nav-anchor" id="Fitting-GLM-models-1" href="#Fitting-GLM-models-1">Fitting GLM models</a></h2><p>To fit a Generalized Linear Model (GLM), use the function, <code>glm(formula, data, family, link)</code>, where,</p><ul><li><p><code>formula</code>: uses column symbols from the DataFrame data, for example, if <code>names(data)=[:Y,:X1,:X2]</code>, then a valid formula is <code>@formula(Y ~ X1 + X2)</code></p></li><li><p><code>data</code>: a DataFrame which may contain NA values, any rows with NA values are ignored</p></li><li><p><code>family</code>: chosen from <code>Bernoulli()</code>, <code>Binomial()</code>, <code>Gamma()</code>, <code>Normal()</code>, or <code>Poisson()</code></p></li><li><p><code>link</code>: chosen from the list below, for example, <code>LogitLink()</code> is a valid link for the <code>Binomial()</code> family</p></li></ul><p>An intercept is included in any GLM by default.</p><h2><a class="nav-anchor" id="Methods-applied-to-fitted-models-1" href="#Methods-applied-to-fitted-models-1">Methods applied to fitted models</a></h2><p>Many of the methods provided by this package have names similar to those in <a href="http://www.r-project.org">R</a>.</p><ul><li><p><code>coef</code>: extract the estimates of the coefficients in the model</p></li><li><p><code>deviance</code>: measure of the model fit, weighted residual sum of squares for lm&#39;s</p></li><li><p><code>dof_residual</code>: degrees of freedom for residuals, when meaningful</p></li><li><p><code>glm</code>: fit a generalized linear model (an alias for <code>fit(GeneralizedLinearModel, ...)</code>)</p></li><li><p><code>lm</code>: fit a linear model (an alias for <code>fit(LinearModel, ...)</code>)</p></li><li><p><code>stderror</code>: standard errors of the coefficients</p></li><li><p><code>vcov</code>: estimated variance-covariance matrix of the coefficient estimates</p></li><li><p><code>predict</code> : obtain predicted values of the dependent variable from the fitted model</p></li></ul><h2><a class="nav-anchor" id="Minimal-examples-1" href="#Minimal-examples-1">Minimal examples</a></h2><h3><a class="nav-anchor" id="Ordinary-Least-Squares-Regression:-1" href="#Ordinary-Least-Squares-Regression:-1">Ordinary Least Squares Regression:</a></h3><pre><code class="language-julia-repl">julia&gt; using DataFrames, GLM

julia&gt; data = DataFrame(X=[1,2,3], Y=[2,4,7])
3×2 DataFrames.DataFrame
│ Row │ X │ Y │
├─────┼───┼───┤
│ 1   │ 1 │ 2 │
│ 2   │ 2 │ 4 │
│ 3   │ 3 │ 7 │

julia&gt; ols = lm(@formula(Y ~ X), data)
StatsModels.DataFrameRegressionModel{GLM.LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

Formula: Y ~ 1 + X

Coefficients:
              Estimate Std.Error  t value Pr(&gt;|t|)
(Intercept)  -0.666667   0.62361 -1.06904   0.4788
X                  2.5  0.288675  8.66025   0.0732

julia&gt; stderror(ols)
2-element Array{Float64,1}:
 0.62361
 0.288675

julia&gt; predict(ols)
3-element Array{Float64,1}:
 1.83333
 4.33333
 6.83333
</code></pre><p>&lt;!– Andreas Noack: As of 9 May 2018 this example doesn&#39;t work so I&#39;ve temporarily commented it out julia&gt; newX = DataFrame(X=[2,3,4]);</p><p>julia&gt; predict(ols, newX, :confint)  3×3 Array{Float64,2}:   4.33333  1.33845   7.32821   6.83333  2.09801  11.5687   9.33333  1.40962  17.257 The columns of the matrix are prediction, 95% lower and upper confidence bounds –&gt;</p><h3><a class="nav-anchor" id="Probit-Regression:-1" href="#Probit-Regression:-1">Probit Regression:</a></h3><pre><code class="language-julia-repl">julia&gt; data = DataFrame(X=[1,2,3], Y=[1,0,1])
3×2 DataFrames.DataFrame
│ Row │ X │ Y │
├─────┼───┼───┤
│ 1   │ 1 │ 1 │
│ 2   │ 2 │ 0 │
│ 3   │ 3 │ 1 │

julia&gt; probit = glm(@formula(Y ~ X), data, Binomial(), ProbitLink())
StatsModels.DataFrameRegressionModel{GLM.GeneralizedLinearModel{GLM.GlmResp{Array{Float64,1},Distributions.Binomial{Float64},GLM.ProbitLink},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

Formula: Y ~ 1 + X

Coefficients:
                 Estimate Std.Error      z value Pr(&gt;|z|)
(Intercept)      0.430727   1.98019     0.217518   0.8278
X            -3.64399e-19   0.91665 -3.97534e-19   1.0000
</code></pre><h2><a class="nav-anchor" id="Other-examples-1" href="#Other-examples-1">Other examples</a></h2><p>An example of a simple linear model in R is</p><pre><code class="language-r">&gt; coef(summary(lm(optden ~ carb, Formaldehyde)))
               Estimate  Std. Error    t value     Pr(&gt;|t|)
(Intercept) 0.005085714 0.007833679  0.6492115 5.515953e-01
carb        0.876285714 0.013534536 64.7444207 3.409192e-07</code></pre><p>The corresponding model with the <code>GLM</code> package is</p><pre><code class="language-julia-repl">julia&gt; using GLM, RDatasets

julia&gt; form = dataset(&quot;datasets&quot;, &quot;Formaldehyde&quot;)
6×2 DataFrames.DataFrame
│ Row │ Carb │ OptDen │
├─────┼──────┼────────┤
│ 1   │ 0.1  │ 0.086  │
│ 2   │ 0.3  │ 0.269  │
│ 3   │ 0.5  │ 0.446  │
│ 4   │ 0.6  │ 0.538  │
│ 5   │ 0.7  │ 0.626  │
│ 6   │ 0.9  │ 0.782  │

julia&gt; lm1 = fit(LinearModel, @formula(OptDen ~ Carb), form)
StatsModels.DataFrameRegressionModel{GLM.LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

Formula: OptDen ~ 1 + Carb

Coefficients:
               Estimate  Std.Error  t value Pr(&gt;|t|)
(Intercept)  0.00508571 0.00783368 0.649211   0.5516
Carb           0.876286  0.0135345  64.7444    &lt;1e-6

julia&gt; confint(lm1)
2×2 Array{Float64,2}:
 -0.0166641  0.0268355
  0.838708   0.913864
</code></pre><p>A more complex example in R is</p><pre><code class="language-r">&gt; coef(summary(lm(sr ~ pop15 + pop75 + dpi + ddpi, LifeCycleSavings)))
                 Estimate   Std. Error    t value     Pr(&gt;|t|)
(Intercept) 28.5660865407 7.3545161062  3.8841558 0.0003338249
pop15       -0.4611931471 0.1446422248 -3.1885098 0.0026030189
pop75       -1.6914976767 1.0835989307 -1.5609998 0.1255297940
dpi         -0.0003369019 0.0009311072 -0.3618293 0.7191731554
ddpi         0.4096949279 0.1961971276  2.0881801 0.0424711387</code></pre><p>with the corresponding Julia code</p><pre><code class="language-julia-repl">julia&gt; LifeCycleSavings = dataset(&quot;datasets&quot;, &quot;LifeCycleSavings&quot;)
50×6 DataFrames.DataFrame
│ Row │ Country        │ SR    │ Pop15 │ Pop75 │ DPI     │ DDPI  │
├─────┼────────────────┼───────┼───────┼───────┼─────────┼───────┤
│ 1   │ Australia      │ 11.43 │ 29.35 │ 2.87  │ 2329.68 │ 2.87  │
│ 2   │ Austria        │ 12.07 │ 23.32 │ 4.41  │ 1507.99 │ 3.93  │
│ 3   │ Belgium        │ 13.17 │ 23.8  │ 4.43  │ 2108.47 │ 3.82  │
│ 4   │ Bolivia        │ 5.75  │ 41.89 │ 1.67  │ 189.13  │ 0.22  │
│ 5   │ Brazil         │ 12.88 │ 42.19 │ 0.83  │ 728.47  │ 4.56  │
│ 6   │ Canada         │ 8.79  │ 31.72 │ 2.85  │ 2982.88 │ 2.43  │
│ 7   │ Chile          │ 0.6   │ 39.74 │ 1.34  │ 662.86  │ 2.67  │
│ 8   │ China          │ 11.9  │ 44.75 │ 0.67  │ 289.52  │ 6.51  │
⋮
│ 42  │ Tunisia        │ 2.81  │ 46.12 │ 1.21  │ 249.87  │ 1.13  │
│ 43  │ United Kingdom │ 7.81  │ 23.27 │ 4.46  │ 1813.93 │ 2.01  │
│ 44  │ United States  │ 7.56  │ 29.81 │ 3.43  │ 4001.89 │ 2.45  │
│ 45  │ Venezuela      │ 9.22  │ 46.4  │ 0.9   │ 813.39  │ 0.53  │
│ 46  │ Zambia         │ 18.56 │ 45.25 │ 0.56  │ 138.33  │ 5.14  │
│ 47  │ Jamaica        │ 7.72  │ 41.12 │ 1.73  │ 380.47  │ 10.23 │
│ 48  │ Uruguay        │ 9.24  │ 28.13 │ 2.72  │ 766.54  │ 1.88  │
│ 49  │ Libya          │ 8.89  │ 43.69 │ 2.07  │ 123.58  │ 16.71 │
│ 50  │ Malaysia       │ 4.71  │ 47.2  │ 0.66  │ 242.69  │ 5.08  │

julia&gt; fm2 = fit(LinearModel, @formula(SR ~ Pop15 + Pop75 + DPI + DDPI), LifeCycleSavings)
StatsModels.DataFrameRegressionModel{GLM.LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

Formula: SR ~ 1 + Pop15 + Pop75 + DPI + DDPI

Coefficients:
                 Estimate   Std.Error   t value Pr(&gt;|t|)
(Intercept)       28.5661     7.35452   3.88416   0.0003
Pop15           -0.461193    0.144642  -3.18851   0.0026
Pop75             -1.6915      1.0836    -1.561   0.1255
DPI          -0.000336902 0.000931107 -0.361829   0.7192
DDPI             0.409695    0.196197   2.08818   0.0425</code></pre><p>The <code>glm</code> function (or equivalently, <code>fit(GeneralizedLinearModel, ...)</code>) works similarly to the R <code>glm</code> function except that the <code>family</code> argument is replaced by a <code>Distribution</code> type and, optionally, a <code>Link</code> type. The first example from <code>?glm</code> in R is</p><pre><code class="language-r">glm&gt; ## Dobson (1990) Page 93: Randomized Controlled Trial :
glm&gt; counts &lt;- c(18,17,15,20,10,20,25,13,12)

glm&gt; outcome &lt;- gl(3,1,9)

glm&gt; treatment &lt;- gl(3,3)

glm&gt; print(d.AD &lt;- data.frame(treatment, outcome, counts))
  treatment outcome counts
1         1       1     18
2         1       2     17
3         1       3     15
4         2       1     20
5         2       2     10
6         2       3     20
7         3       1     25
8         3       2     13
9         3       3     12

glm&gt; glm.D93 &lt;- glm(counts ~ outcome + treatment, family=poisson())

glm&gt; anova(glm.D93)
Analysis of Deviance Table

Model: poisson, link: log

Response: counts

Terms added sequentially (first to last)


          Df Deviance Resid. Df Resid. Dev
NULL                          8    10.5814
outcome    2   5.4523         6     5.1291
treatment  2   0.0000         4     5.1291

glm&gt; ## No test:
glm&gt; summary(glm.D93)

Call:
glm(formula = counts ~ outcome + treatment, family = poisson())

Deviance Residuals:
       1         2         3         4         5         6         7         8  
-0.67125   0.96272  -0.16965  -0.21999  -0.95552   1.04939   0.84715  -0.09167  
       9  
-0.96656  

Coefficients:
              Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)  3.045e+00  1.709e-01  17.815   &lt;2e-16 ***
outcome2    -4.543e-01  2.022e-01  -2.247   0.0246 *  
outcome3    -2.930e-01  1.927e-01  -1.520   0.1285    
treatment2   3.795e-16  2.000e-01   0.000   1.0000    
treatment3   3.553e-16  2.000e-01   0.000   1.0000    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

(Dispersion parameter for poisson family taken to be 1)

    Null deviance: 10.5814  on 8  degrees of freedom
Residual deviance:  5.1291  on 4  degrees of freedom
AIC: 56.761

Number of Fisher Scoring iterations: 4</code></pre><p>In Julia this becomes</p><pre><code class="language-julia-repl">julia&gt; using DataFrames, CategoricalArrays, GLM

julia&gt; dobson = DataFrame(Counts    = [18.,17,15,20,10,20,25,13,12],
                          Outcome   = categorical([1,2,3,1,2,3,1,2,3]),
                          Treatment = categorical([1,1,1,2,2,2,3,3,3]))
9×3 DataFrames.DataFrame
│ Row │ Counts │ Outcome │ Treatment │
├─────┼────────┼─────────┼───────────┤
│ 1   │ 18.0   │ 1       │ 1         │
│ 2   │ 17.0   │ 2       │ 1         │
│ 3   │ 15.0   │ 3       │ 1         │
│ 4   │ 20.0   │ 1       │ 2         │
│ 5   │ 10.0   │ 2       │ 2         │
│ 6   │ 20.0   │ 3       │ 2         │
│ 7   │ 25.0   │ 1       │ 3         │
│ 8   │ 13.0   │ 2       │ 3         │
│ 9   │ 12.0   │ 3       │ 3         │


julia&gt; gm1 = fit(GeneralizedLinearModel, @formula(Counts ~ Outcome + Treatment), dobson, Poisson())
StatsModels.DataFrameRegressionModel{GLM.GeneralizedLinearModel{GLM.GlmResp{Array{Float64,1},Distributions.Poisson{Float64},GLM.LogLink},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

Formula: Counts ~ 1 + Outcome + Treatment

Coefficients:
                 Estimate Std.Error     z value Pr(&gt;|z|)
(Intercept)       3.04452  0.170899     17.8148   &lt;1e-70
Outcome: 2      -0.454255  0.202171    -2.24689   0.0246
Outcome: 3      -0.292987  0.192742     -1.5201   0.1285
Treatment: 2  4.61065e-16       0.2 2.30532e-15   1.0000
Treatment: 3  3.44687e-17       0.2 1.72344e-16   1.0000

julia&gt; deviance(gm1)
5.129141077001145</code></pre><p>Typical distributions for use with <code>glm</code> and their canonical link functions are</p><pre><code class="language-none">Bernoulli (LogitLink)
 Binomial (LogitLink)
    Gamma (InverseLink)
   Normal (IdentityLink)
  Poisson (LogLink)</code></pre><p>Currently the available Link types are</p><pre><code class="language-none">CauchitLink
CloglogLink
IdentityLink
InverseLink
LogitLink
LogLink
ProbitLink
SqrtLink</code></pre><h2><a class="nav-anchor" id="Separation-of-response-object-and-predictor-object-1" href="#Separation-of-response-object-and-predictor-object-1">Separation of response object and predictor object</a></h2><p>The general approach in this code is to separate functionality related to the response from that related to the linear predictor.  This allows for greater generality by mixing and matching different subtypes of the abstract type <code>LinPred</code> and the abstract type <code>ModResp</code>.</p><p>A <code>LinPred</code> type incorporates the parameter vector and the model matrix.  The parameter vector is a dense numeric vector but the model matrix can be dense or sparse.  A <code>LinPred</code> type must incorporate some form of a decomposition of the weighted model matrix that allows for the solution of a system <code>X&#39;W * X * delta=X&#39;wres</code> where <code>W</code> is a diagonal matrix of &quot;X weights&quot;, provided as a vector of the square roots of the diagonal elements, and <code>wres</code> is a weighted residual vector.</p><p>Currently there are two dense predictor types, <code>DensePredQR</code> and <code>DensePredChol</code>, and the usual caveats apply.  The Cholesky version is faster but somewhat less accurate than that QR version. The skeleton of a distributed predictor type is in the code but not yet fully fleshed out.  Because Julia by default uses OpenBLAS, which is already multi-threaded on multicore machines, there may not be much advantage in using distributed predictor types.</p><p>A <code>ModResp</code> type must provide methods for the <code>wtres</code> and <code>sqrtxwts</code> generics.  Their values are the arguments to the <code>updatebeta</code> methods of the <code>LinPred</code> types.  The <code>Float64</code> value returned by <code>updatedelta</code> is the value of the convergence criterion.</p><p>Similarly, <code>LinPred</code> types must provide a method for the <code>linpred</code> generic.  In general <code>linpred</code> takes an instance of a <code>LinPred</code> type and a step factor.  Methods that take only an instance of a <code>LinPred</code> type use a default step factor of 1.  The value of <code>linpred</code> is the argument to the <code>updatemu</code> method for <code>ModResp</code> types.  The <code>updatemu</code> method returns the updated deviance.</p><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><h3><a class="nav-anchor" id="Types-defined-in-the-package-1" href="#Types-defined-in-the-package-1">Types defined in the package</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.LinearModel" href="#GLM.LinearModel"><code>GLM.LinearModel</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LinearModel</code></pre><p>A combination of a <a href="index.html#GLM.LmResp"><code>LmResp</code></a> and a <a href="index.html#GLM.LinPred"><code>LinPred</code></a></p><p><strong>Members</strong></p><ul><li><p><code>rr</code>: a <code>LmResp</code> object</p></li><li><p><code>pp</code>: a <code>LinPred</code> object</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/lm.jl#L115-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.LmResp" href="#GLM.LmResp"><code>GLM.LmResp</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LmResp</code></pre><p>Encapsulates the response for a linear model</p><p><strong>Members</strong></p><ul><li><p><code>mu</code>: current value of the mean response vector or fitted value</p></li><li><p><code>offset</code>: optional offset added to the linear predictor to form <code>mu</code></p></li><li><p><code>wts</code>: optional vector of prior weights</p></li><li><p><code>y</code>: observed response vector</p></li></ul><p>Either or both <code>offset</code> and <code>wts</code> may be of length 0</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/lm.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.LinPred" href="#GLM.LinPred"><code>GLM.LinPred</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LinPred</code></pre><p>Abstract type representing a linear predictor</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/GLM.jl#L86-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.GlmResp" href="#GLM.GlmResp"><code>GLM.GlmResp</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GlmResp</code></pre><p>The response vector and various derived vectors in a generalized linear model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmfit.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.DensePredQR" href="#GLM.DensePredQR"><code>GLM.DensePredQR</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DensePredQR</code></pre><p>A <code>LinPred</code> type with a dense, unpivoted QR decomposition of <code>X</code></p><p><strong>Members</strong></p><ul><li><p><code>X</code>: Model matrix of size <code>n</code> × <code>p</code> with <code>n ≥ p</code>.  Should be full column rank.</p></li><li><p><code>beta0</code>: base coefficient vector of length <code>p</code></p></li><li><p><code>delbeta</code>: increment to coefficient vector, also of length <code>p</code></p></li><li><p><code>scratchbeta</code>: scratch vector of length <code>p</code>, used in <a href="index.html#GLM.linpred!"><code>linpred!</code></a> method</p></li><li><p><code>qr</code>: a <code>QRCompactWY</code> object created from <code>X</code>, with optional row weights.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/linpred.jl#L35-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.DensePredChol" href="#GLM.DensePredChol"><code>GLM.DensePredChol</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DensePredChol{T}</code></pre><p>A <code>LinPred</code> type with a dense Cholesky factorization of <code>X&#39;X</code></p><p><strong>Members</strong></p><ul><li><p><code>X</code>: model matrix of size <code>n</code> × <code>p</code> with <code>n ≥ p</code>.  Should be full column rank.</p></li><li><p><code>beta0</code>: base coefficient vector of length <code>p</code></p></li><li><p><code>delbeta</code>: increment to coefficient vector, also of length <code>p</code></p></li><li><p><code>scratchbeta</code>: scratch vector of length <code>p</code>, used in <a href="index.html#GLM.linpred!"><code>linpred!</code></a> method</p></li><li><p><code>chol</code>: a <code>Base.LinAlg.Cholesky</code> object created from <code>X&#39;X</code>, possibly using row weights.</p></li><li><p><code>scratchm1</code>: scratch Matrix{T} of the same size as <code>X</code></p></li><li><p><code>scratchm2</code>: scratch Matrix{T} os the same size as <code>X&#39;X</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/linpred.jl#L75-L89">source</a></section><h3><a class="nav-anchor" id="Constructors-for-models-1" href="#Constructors-for-models-1">Constructors for models</a></h3><p>The most general approach to fitting a model is with the <a href="@ref"><code>fit</code></a> function, as in</p><pre><code class="language-julia-repl">julia&gt; fit(LinearModel, hcat(ones(10), 1:10), randn(MersenneTwister(12321), 10))
GLM.LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}}:

Coefficients:
      Estimate Std.Error  t value Pr(&gt;|t|)
x1    0.717436  0.775175 0.925515   0.3818
x2   -0.152062  0.124931 -1.21717   0.2582</code></pre><p>This model can also be fit as</p><pre><code class="language-julia-repl">julia&gt; lm(hcat(ones(10), 1:10), randn(MersenneTwister(12321), 10))
GLM.LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}}:

Coefficients:
      Estimate Std.Error  t value Pr(&gt;|t|)
x1    0.717436  0.775175 0.925515   0.3818
x2   -0.152062  0.124931 -1.21717   0.2582</code></pre><h3><a class="nav-anchor" id="Methods-for-model-updating-1" href="#Methods-for-model-updating-1">Methods for model updating</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.delbeta!" href="#GLM.delbeta!"><code>GLM.delbeta!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">delbeta!(p::LinPred, r::Vector)</code></pre><p>Evaluate and return <code>p.delbeta</code> the increment to the coefficient vector from residual <code>r</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/linpred.jl#L63-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.linpred!" href="#GLM.linpred!"><code>GLM.linpred!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linpred!(out, p::LinPred, f::Real=1.0)</code></pre><p>Overwrite <code>out</code> with the linear predictor from <code>p</code> with factor <code>f</code></p><p>The effective coefficient vector, <code>p.scratchbeta</code>, is evaluated as <code>p.beta0 .+ f * p.delbeta</code>, and <code>out</code> is updated to <code>p.X * p.scratchbeta</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/linpred.jl#L1-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.linpred" href="#GLM.linpred"><code>GLM.linpred</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linpred(p::LinPred, f::Read=1.0)</code></pre><p>Return the linear predictor <code>p.X * (p.beta0 .+ f * p.delbeta)</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/linpred.jl#L13-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.installbeta!" href="#GLM.installbeta!"><code>GLM.installbeta!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">installbeta!(p::LinPred, f::Real=1.0)</code></pre><p>Install <code>pbeta0 .+= f * p.delbeta</code> and zero out <code>p.delbeta</code>.  Return the updated <code>p.beta0</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/linpred.jl#L20-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.cancancel" href="#GLM.cancancel"><code>GLM.cancancel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cancancel(r::GlmResp{V,D,L})</code></pre><p>Returns <code>true</code> if dμ/dη for link <code>L</code> is the variance function for distribution <code>D</code></p><p>When <code>L</code> is the canonical link for <code>D</code> the derivative of the inverse link is a multiple of the variance function for <code>D</code>.  If they are the same a numerator and denominator term in the expression for the working weights will cancel.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmfit.jl#L63-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.updateμ!" href="#GLM.updateμ!"><code>GLM.updateμ!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">updateμ!{T&lt;:FPVector}(r::GlmResp{T}, linPr::T)</code></pre><p>Update the mean, working weights and working residuals, in <code>r</code> given a value of the linear predictor, <code>linPr</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmfit.jl#L77-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.wrkresp" href="#GLM.wrkresp"><code>GLM.wrkresp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">wrkresp(r::GlmResp)</code></pre><p>The working response, <code>r.eta + r.wrkresid - r.offset</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmfit.jl#L121-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.wrkresp!" href="#GLM.wrkresp!"><code>GLM.wrkresp!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">wrkresp!{T&lt;:FPVector}(v::T, r::GlmResp{T})</code></pre><p>Overwrite <code>v</code> with the working response of <code>r</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmfit.jl#L128-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.dispersion" href="#GLM.dispersion"><code>GLM.dispersion</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dispersion(m::AbstractGLM, sqr::Bool=false)</code></pre><p>Return the estimated dispersion (or scale) parameter for a model&#39;s distribution, generally written σ² for linear models and ϕ for generalized linear models. It is, by definition, equal to 1 for the Bernoulli, Binomial, and Poisson families.</p><p>If <code>sqr</code> is <code>true</code>, the squared dispersion parameter is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmfit.jl#L320-L328">source</a></section><h3><a class="nav-anchor" id="Links-and-methods-applied-to-them-1" href="#Links-and-methods-applied-to-them-1">Links and methods applied to them</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.Link" href="#GLM.Link"><code>GLM.Link</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Link</code></pre><p>An abstract type whose subtypes determine methods for <a href="index.html#GLM.linkfun"><code>linkfun</code></a>, <a href="index.html#GLM.linkinv"><code>linkinv</code></a>, <a href="index.html#GLM.mueta"><code>mueta</code></a>, and <a href="index.html#GLM.inverselink"><code>inverselink</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.Link01" href="#GLM.Link01"><code>GLM.Link01</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Link01</code></pre><p>An abstract subtype of <a href="index.html#GLM.Link"><code>Link</code></a> which are links defined on (0, 1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.CauchitLink" href="#GLM.CauchitLink"><code>GLM.CauchitLink</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CauchitLink</code></pre><p>A <a href="index.html#GLM.Link01"><code>Link01</code></a> corresponding to the standard Cauchy distribution, <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Cauchy"><code>Distributions.Cauchy</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L16-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.CloglogLink" href="#GLM.CloglogLink"><code>GLM.CloglogLink</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CloglogLink</code></pre><p>A <a href="index.html#GLM.Link01"><code>Link01</code></a> corresponding to the extreme value (or log-Wiebull) distribution.  The link is the complementary log-log transformation, <code>log(1 - log(-μ))</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L24-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.IdentityLink" href="#GLM.IdentityLink"><code>GLM.IdentityLink</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">IdentityLink</code></pre><p>The canonical <a href="index.html#GLM.Link"><code>Link</code></a> for the <code>Normal</code> distribution, defined as <code>η = μ</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L32-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.InverseLink" href="#GLM.InverseLink"><code>GLM.InverseLink</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">InverseLink</code></pre><p>The canonical <a href="index.html#GLM.Link"><code>Link</code></a> for <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Gamma"><code>Distributions.Gamma</code></a> distribution, defined as <code>η = inv(μ)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L39-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.InverseSquareLink" href="#GLM.InverseSquareLink"><code>GLM.InverseSquareLink</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">InverseSquareLink</code></pre><p>The canonical <a href="index.html#GLM.Link"><code>Link</code></a> for <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.InverseGaussian"><code>Distributions.InverseGaussian</code></a> distribution, defined as <code>η = inv(abs2(μ))</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L46-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.LogitLink" href="#GLM.LogitLink"><code>GLM.LogitLink</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LogitLink</code></pre><p>The canonical <a href="index.html#GLM.Link01"><code>Link01</code></a> for <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Bernoulli"><code>Distributions.Bernoulli</code></a> and <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Binomial"><code>Distributions.Binomial</code></a>. The inverse link, <a href="index.html#GLM.linkinv"><code>linkinv</code></a>, is the c.d.f. of the standard logistic distribution, <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Logistic"><code>Distributions.Logistic</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L53-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.LogLink" href="#GLM.LogLink"><code>GLM.LogLink</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LogLink</code></pre><p>The canonical <a href="index.html#GLM.Link"><code>Link</code></a> for <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Poisson"><code>Distributions.Poisson</code></a>, defined as <code>η = log(μ)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L62-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.ProbitLink" href="#GLM.ProbitLink"><code>GLM.ProbitLink</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ProbitLink</code></pre><p>A <a href="index.html#GLM.Link01"><code>Link01</code></a> whose <a href="index.html#GLM.linkinv"><code>linkinv</code></a> is the c.d.f. of the standard normal distribution, <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Normal"><code>Distributions.Normal()</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L69-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.SqrtLink" href="#GLM.SqrtLink"><code>GLM.SqrtLink</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SqrtLink</code></pre><p>A <a href="index.html#GLM.Link"><code>Link</code></a> defined as <code>η = √μ</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L77-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.linkfun" href="#GLM.linkfun"><code>GLM.linkfun</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linkfun(L::Link, μ)</code></pre><p>Return <code>η</code>, the value of the linear predictor for link <code>L</code> at mean <code>μ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; μ = inv(10):inv(5):1
0.1:0.2:0.9

julia&gt; show(linkfun.(LogitLink(), μ))
[-2.19722, -0.847298, 0.0, 0.847298, 2.19722]
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L84-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.linkinv" href="#GLM.linkinv"><code>GLM.linkinv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linkinv(L::Link, η)</code></pre><p>Return <code>μ</code>, the mean value, for link <code>L</code> at linear predictor value <code>η</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; μ = inv(10):inv(5):1; showcompact(collect(μ))
[0.1, 0.3, 0.5, 0.7, 0.9]
julia&gt; η = logit.(μ); showcompact(η)
[-2.19722, -0.847298, 0.0, 0.847298, 2.19722]
julia&gt; showcompact(linkinv.(LogitLink(), η))
[0.1, 0.3, 0.5, 0.7, 0.9]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L101-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.mueta" href="#GLM.mueta"><code>GLM.mueta</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mueta(L::Link, η)</code></pre><p>Return the derivative of <a href="index.html#GLM.linkinv"><code>linkinv</code></a>, <code>dμ/dη</code>, for link <code>L</code> at linear predictor value <code>η</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; showcompact(mueta(LogitLink(), 0.0))
0.25
julia&gt; showcompact(mueta(CloglogLink(), 0.0))
0.367879
julia&gt; showcompact(mueta(LogLink(), 2.0))
7.38906</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L118-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.inverselink" href="#GLM.inverselink"><code>GLM.inverselink</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">inverselink(L::Link, η)</code></pre><p>Return a 3-tuple of the inverse link, the derivative of the inverse link, and when appropriate, the variance function <code>μ*(1 - μ)</code>.</p><p>The variance function is returned as NaN unless the range of μ is (0, 1)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; showcompact(inverselink(LogitLink(), 0.0))
(0.5, 0.25, 0.25)
julia&gt; showcompact(inverselink(CloglogLink(), 0.0))
(0.632121, 0.367879, 0.232544)
julia&gt; showcompact(inverselink(LogLink(), 2.0))
(7.38906, 7.38906, NaN)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L135-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.canonicallink" href="#GLM.canonicallink"><code>GLM.canonicallink</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">canonicallink(D::Distribution)</code></pre><p>Return the canonical link for distribution <code>D</code>, which must be in the exponential family.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; canonicallink(Bernoulli())
GLM.LogitLink()</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L154-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.glmvar" href="#GLM.glmvar"><code>GLM.glmvar</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">glmvar(D::Distribution, μ)</code></pre><p>Return the value of the variance function for <code>D</code> at <code>μ</code></p><p>The variance of <code>D</code> at <code>μ</code> is the product of the dispersion parameter, ϕ, which does not depend on <code>μ</code> and the value of <code>glmvar</code>.  In other words <code>glmvar</code> returns the factor of the variance that depends on <code>μ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; μ = inv(6):inv(3):1; showcompact(collect(μ))
[0.166667, 0.5, 0.833333]
julia&gt; showcompact(glmvar.(Normal(), μ))    # constant for Normal()
[1.0, 1.0, 1.0]
julia&gt; showcompact(glmvar.(Bernoulli(), μ)) # μ * (1 - μ) for Bernoulli()
[0.138889, 0.25, 0.138889]
julia&gt; showcompact(glmvar.(Poisson(), μ))   # μ for Poisson()
[0.166667, 0.5, 0.833333]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L254-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.mustart" href="#GLM.mustart"><code>GLM.mustart</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mustart(D::Distribution, y, wt)</code></pre><p>Return a starting value for μ.</p><p>For some distributions it is appropriate to set <code>μ = y</code> to initialize the IRLS algorithm but for others, notably the Bernoulli, the values of <code>y</code> are not allowed as values of <code>μ</code> and must be modified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; showcompact(mustart(Bernoulli(), 0.0, 1))
0.25
julia&gt; showcompact(mustart(Bernoulli(), 1.0, 1))
0.75
julia&gt; showcompact(mustart(Binomial(), 0.0, 10))
0.0454545
julia&gt; showcompact(mustart(Normal(), 0.0, 1))
0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L283-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.devresid" href="#GLM.devresid"><code>GLM.devresid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">devresid(D, y, μ)</code></pre><p>Return the squared deviance residual of <code>μ</code> from <code>y</code> for distribution <code>D</code></p><p>The deviance of a GLM can be evaluated as the sum of the squared deviance residuals.  This is the principal use for these values.  The actual deviance residual, say for plotting, is the signed square root of this value</p><pre><code class="language-julia">sign(y - μ) * sqrt(devresid(D, y, μ))</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; showcompact(devresid(Normal(), 0, 0.25))     # abs2(y - μ)
0.0625
julia&gt; showcompact(devresid(Bernoulli(), 1, 0.75))  # -2log(μ) when y == 1
0.575364
julia&gt; showcompact(devresid(Bernoulli(), 0, 0.25))  # -2log1p(-μ) = -2log(1-μ) when y == 0
0.575364</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L312-L333">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.dispersion_parameter" href="#GLM.dispersion_parameter"><code>GLM.dispersion_parameter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dispersion_parameter(D)  # not exported</code></pre><p>Does distribution <code>D</code> have a separate dispersion parameter, ϕ?</p><p>Returns <code>false</code> for the <code>Bernoulli</code>, <code>Binomial</code> and <code>Poisson</code> distributions, <code>true</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; show(GLM.dispersion_parameter(Normal()))
true
julia&gt; show(GLM.dispersion_parameter(Bernoulli()))
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L358-L372">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.loglik_obs" href="#GLM.loglik_obs"><code>GLM.loglik_obs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loglik_obs(D, y, μ, wt, ϕ)  # not exported</code></pre><p>Returns <code>wt * logpdf(D(μ, ϕ), y)</code> where the parameters of <code>D</code> are derived from <code>μ</code> and <code>ϕ</code>.</p><p>The <code>wt</code> argument is a multiplier of the result except in the case of the <code>Binomial</code> where <code>wt</code> is the number of trials and <code>μ</code> is the proportion of successes.</p><p>The loglikelihood of a fitted model is the sum of these values over all the observations.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/886f4fc8c2aa19487852746d754dd2874c43dac8/src/glmtools.jl#L376-L385">source</a></section><footer><hr/></footer></article></body></html>
